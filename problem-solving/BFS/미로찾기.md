# 문제
- N x M 크기의 미로가 있다.
- 처음 위치는 (1,1)이고 미로의 출구는 (N, M)의 위치에 존재한다.
- 괴물이 있는 부분은 0으로, 괴물이 없는 부분은 1로 표시되어 있다.
- 미로에서 탈출하기 위해 움직여야 하는 최소 칸의 개수를 구한다.
- 칸을 셀 때는 시작 칸과 마지막 칸을 모두 포함한다.

# 입력
- 첫째 줄에 두 정수 N, M(4 <= N,M <= 200)이 주어진다.
- N개 줄에는 각각 M개의 정수(0 혹은 1)로 미로의 정보가 주어진다.
- 시작 칸과 마지막 칸은 항상 1이다.

# 입력 예시
```
110
010
011
```
```
5 6
101010
111111
000001
111111
111111
```

# 출력 예시
```
5
```
```
10
```

# 풀이 코드
``` python
import sys
from collections import deque
sys.stdin=open("../input.txt", "rt")

n,m = map(int, input().split(" "))
matrix = [list(map(int, sys.stdin.readline().rstrip())) for i in range(1, n+1)] # 입력으로 주어진 미로
visited = [[False] * m for _ in range(n)] # 방문 체크 배열

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def BFS(x, y):
    queue = deque()
    queue.append((x, y))
    visited[x][y] = True

    # queue가 빌때까지 반복
    while queue:
        x, y = queue.popleft()
        # 상하좌우 네 방향으로 탐색
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            # 범위 밖인 경우 제외
            if nx < 0 or nx >= n or ny < 0 or ny >= m:
                continue

            # 괴물이 있는 경우 제외
            if matrix[nx][ny] == 0:
                continue

            if not visited[nx][ny]:
                visited[nx][ny] = True
                matrix[nx][ny] = matrix[x][y] + 1
                queue.append((nx, ny))

            # 정답을 찾은 경우
            if nx == n-1 and ny == m-1:
                return matrix[nx][ny]

answer = BFS(0, 0)
print(answer)
```

# 풀이 과정
최단거리를 찾는 문제는 BFS 알고리즘을 이용하면 효율적으로 풀 수 있다.
최단거리를 구하는 문제에서 BFS 알고리즘을 사용하는 이유는 BFS가 너비 우선 탐색을 하기 때문이다.
즉, 현재 노드에서 인접한 노드를 모두 탐색한 후 다음에 인접한 노드들을 탐색하는 식으로 진행된다.
이러한 방식으로 탐색하면, 시작점에서 부터 각 노드까지의 최단거리를 먼저 찾을 수 있다.

BFS 알고리즘은 큐를 이용하여 구현한다. 큐에 시작점을 넣은 후, 시작점으로 부터 이동할 수 있는 노드들을 큐에 넣는다.
그리고 큐에서 노드를 하나씩 꺼내면서 해당 노드와 인접한 노드를 방문한다.
인접한 노드가 도착지점이면 BFS를 종료하고, 도착점이 아니면 인접한 노드를 큐에 추가한다.
이 과정을 반복하면서 시작점에서 도착점까지의 최단 거리를 찾을 수 있다.

입력으로 주어진 n과 m을 이용하여 n x m 크기의 미로를 입력받는다. 그리고 방문 체크를 위해 visited 배열을 만들고 BFS 탐색에 필요한 dx, dy를 정의했다.

이후 BFS 함수를 정의한다. BFS 함수는 시작 위치인 (0,0)부터 탐색을 시작하고, 쿠에 시작 위치를 넣고 visited 배열을 True로 변견한다.

큐가 빌 때까지 반목문을 돌면서 상하좌우 네 방향으로 이동한다. 이때 범위 밖이거나 괴물이 있는 경우(0 인경우)는 제외하고,
visited 배열이 False인 경우에만 탐색을 진행한다.
탐색한 위치의 visited 배열을 True로 변경하고 이동한 위치의 값에는 현재 위치의 값에 1을 더한 값을 넣는다. (처음 위치는 1이기 때문에 이동할 때마다 1을 더해준다)

이동한 위치가 미로의 출구인 경우, 이동한 위치의 값을 리턴하여 탐색을 종료한다.

마지막으로 정의한 BFS 함수를 호출하고 그 결과를 출력한다. 이 값은 시작 위치부터 미로의 출구까지 이동할 때 최소한으로 움직여야 하는 칸의 개수를 나타낸다.

# 시간복잡도
이 코드의 시간 복잡도는 각 위치에서 BFS를 호출하는 것으로 O(NM)이 된다.
또한 BFS 알고리즘을 사용하는 코드의 시간복잡도는 O(NM)이 된다. 미로 내의 모든 칸을 한번씩 방문하기 때문이다.
정확히는 각 칸에서 최대 한번씩 상하좌우 4개의 인접한 칸을 방문하기 때문에 총 시간복잡도는 O(4NM)이 된다.
그러나 빅오표기법에서는 상수를 무시하므로 O(NM)으로 표기할 수 있다.






