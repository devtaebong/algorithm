# 미로탐색(백준 2178번)

# 문제 
- N x M 크기의 배열로 표현되는 미로가 있다.
- 미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다.
- (1,1)에서 출발하여 (N,M)의 위치로 이동할 때 지나야 하는 최소한의 칸 수를 구한다.
- 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

# 입력
- 첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.

# 출력
첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.

# 입력 예시
```
4 6
101111
101010
101011
111011
```

```
4 6
110110
110110
111111
111101
```

```
2 25
1011101110111011101110111
1110111011101110111011101
```

# 예제 출력
```
15
```
```
9
```
```
38
```

# 풀이 코드
```python
import sys
from collections import deque
sys.stdin=open("../input.txt", "rt")

n,m = map(int, input().split(" "))
matrix = [list(map(int, sys.stdin.readline().rstrip())) for i in range(n)]
visited = [[False] * m for _ in range(n)]

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def BFS(x, y):
    queue = deque()
    queue.append((x, y))

    # 큐가 빌 때까지 반복한다.
    while queue:
        x, y = queue.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            # 범위 밖일 경우 종료
            if nx < 0 or nx >= n or ny < 0 or ny >= m:
                continue

            # 0일 경우 종료
            if matrix[nx][ny] == 0:
                continue

            # 방문하지 않은 노드만 탐색
            if not visited[nx][ny]:
                visited[nx][ny] = True
                matrix[nx][ny] += matrix[x][y]
                queue.append((nx, ny))

        if x == n-1 and y == m-1:
            return matrix[x][y]

answer = BFS(0,0)
print(answer)
```

# 풀이과정
(1,1) 부터 (n,m)까지의 최단거리를 구하는 문제로 BFS 알고리즘을 사용하여 해결했다.

1. 입력으로 n,m / n x m 크기의 미로를 받는다.
2. 방문한 노드를 체크할 수 있는 visited 배열과 BFS 탐색에 필요한 dx와 dy를 정의한다.
3. BFS 함수를 정의하여 큐에 시작위치를 넣고 큐가 빌때까지 루프를 돌면서 상하좌우 네방향을 탐색한다.
4. 범위 밖이거나 0인 경우를 제외하고 visited 배열이 False인 경우만 탐색을 진행한다.
5. 다음 노드를 True로 변경하고 현재 노드 값을 더해준다.
6. 이동한 위치가 미로의 출구인 경우 이동한 위치의 값을 리턴하여 탐색을 종료한다.
7. 마지막으로 BFS 함수를 호출하여 결과를 출력한다.

# 시간복잡도
이 코드의 시간복잡도는 BFS 알고리즘에 의해 결정된다. 미로의 크기가 N x M 이기 때문에,
최악의 경우 모든 노드를 방문하는 시간 복잡도는 O(NM)이 소요된다.

하지만 큐에 넣을 노드 수가 상대적으로 적어서 큐에 노드를 추가하거나 삭제하는 시간 복잡도인 O(1)이 걸리는 경우가 많다.
따라서 평균 시간 복잡도는 O(NM)보다 훨씬 낮을 가능성이 높다.

또한 각 노드를 방문할 때마다 visited 배열을 사용하여 방문여부를 체크하는데,
이 방법은 시간복잡도를 O(1)로 처리할 수 있어서 전체 시간복잡도에 큰 영향을 미치지 않을 것이다.
따라서 이 코드의 시간 복잡도는 O(NM)이다.

