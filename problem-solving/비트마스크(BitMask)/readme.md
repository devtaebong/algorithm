# 비트마스크(BitMask)
비트마스크 연산은 이진수(Binary) 비트를 이용한 연산 기법으로 논리 연산을 비트단위로 처리하는 방식이다. 이를 이용하여 하나의 정수형 변수에 여러가지 정보를 저장하고 이 정보를 빠르게 처리할 수 있다.

예를들어 5개의 원소를 가진 배열이 있다고 가정해보자. 이 배열의 각 원소를 표현하기 위해 5개의 변수를 사용해야 한다. 하지만 8개의 변수를 사용하면 비효율적이며 메모리도 많이 소모한다. 이를 해결하기 위해 1개의 정수형변수(int)를 이용하여 5개의 원소를 표현할 수 있다.

## 비트마스크 기술의 장점
#### 1. 빠른 실행 속도
비트마스크 연산은 CPU의 명령어 수준에서 지원되기 때문에 매우 빠른 실행속도를 보장한다. 이는 빅테이터와 같이 대량의 데이터를 처리할 때 유용하다.
<br>

#### 2. 메모리 절약
비트마스크 연산은 데이터를 비트 단위로 표현하기 때문에 저장 공간을 매우 효율적을 사용할 수 있다. 이는 메모리 제한이 있는 시스템에서 매우 유용하다
<br>

#### 3. 병렬 처리 가능
비트마스크 연산은 여러 개의 비트연산을 동시에 수행할 수 있기 때문에 병렬 처리가 가능하다. 이는 멀티코어 CPU를 사용하는 시스템에서 매우 유용하다.
<br>

#### 4. 집합 연산 가능
비트마스크 연산은 집합(set) 연산을 수행하는데에 유용하다. 예를 들어 두개의 집합을 비교하거나, 교집합, 합집합, 차집합 등의 연산을 수행하는데에 유리하다.
<br>

따라서 비트마스크 연산은 빠른 실행속도, 메모리절약, 병렬처리가능, 집합연산가능 등의 장점을 가지고 있으며, 이를 활용하여 다양한 알고리즘 및 자료구조를 구현할 수 있다.
<br><br>

## 예시

예를들어 8개의 원소를 가진 배열을 다음과 같이 정의할 수 있다.

``` java
int[] arr = {1, 3, 4, 5, 9};
```
<br>

이 배열을 정수형 변수에 저장하기 위해서는 각 원소가 포함됐는지를 비트로 나타내면 된다. 즉, 1번 원소가 포함됐으면 첫번째 비트를 1로 설정하고, 2번 원소가 포함됐으면 두번째 비트를 1로 설정하는 식이다. 이를 자바코드로 표현하면 다음과 같다.

```
int bitmask = 0;
bitmask |= (1 << 1); // 1번 원소가 포함됐으므로, 첫 번째 비트를 1로 설정
```
위 코드에서 ``` |= ``` 은 ``` 비트 OR ``` 연산자이고,  ``` << ```는 왼쪽 시프트 연산자이다. 첫번째 비트를 1로 설정하기 위해 ``` (1 << 1) ``` 을 이용할 수 있다. ``` (1 << 1) ``` 는 "00000010" 을 의미하며 이를 ``` bitmask ``` 변수에 비트 ``` OR ``` 연산을 하여 첫 번째 비트를 1로 설정한다.
이를 이용하여 3번원소가 포함됐을 때와 4, 5, 9 원소가 포함됐을 때를 추가하면 비트는 ``` 1000111010 ``` 값을 갖고 10진수로 표현하면 ```570``` 의 값을 갖게된다.
<br><br>

## 구현방법
``` int[] S = {1, 3, 4, 5, 9}``` <br>
```{1, 3, 4, 5, 9}``` = ```2¹ + 2³ + 2⁴ + 2⁵ + 2⁹``` = ``` 570``` <br>
자바코드로는 아래와 같이 구현할 수 있다.

```
int bitmask = 0;
bitmask |= (1 << 1); // 1번 원소가 포함됐으므로, 첫 번째 비트를 1로 설정
bitmask |= (1 << 3); // 3번 원소가 포함됐으므로, 세 번째 비트를 1로 설정
bitmask |= (1 << 4); // 4번 원소가 포함됐으므로, 네 번째 비트를 1로 설정
bitmask |= (1 << 7); // 7번 원소가 포함됐으므로, 일곱 번째 비트를 1로 설정
```
``` System.out.println(bitmask)``` // 570
<br><br>


## 비트연산 (Bitwise operation)
#### shift left(<<)
``` A << B``` : A를 왼쪽으로 B비트 만큼 민다.
```java
1 << 0 = 1
        1 << 1 = 2 (10₂)
        1 << 2 = 4 (100₂)
        1 << 3 = 8 (1000₂)
        1 << 4 = 16 (1000₂)
        3 << 0 = (11₂)
        3 << 3 = (11000₂)
        5 << 10 = (1010000000000₂)
```
10 진법에서 3이 있을때 왼쪽으로 3번 밀면 ```3 x 10³ = 3000``` 이라고 할 수 있다.
마찬가지로 2진법에서 3이 있을때 왼쪽으로 3번 밀면 ```3 x 2³ = 24``` 의 값을 갖게 된다.

#### shift right(>>)
```A>>B``` : A를 오른쪽으로 B비트 만큼 민다.
```java
1 >> 0 = 1
        1(1₂) >> 1 = 0 (0₂)
        10(1010₂) >> 1 = 5 (101₂)
        10(1010₂) >> 2 = 2 (10₂)
        10(1010₂) >> 3 = 1 (1₂)
        30()
```

### 정리하면
- shift left 연산은 ``` A x 2ⁿ```와 같다.
- shift right 연산은 ```A / 2ⁿ``` 와 같다.
- ```(A+B)/2``` 는 ```(A+B) >> 1``` 로 쓸 수 있다.
- ```(A+B)/2²``` 는 ```(A+B) >> 2``` 로 쓸 수 있다.

# 연산
집합의 검사, 추가, 삭제 등의 연산의 복잡도가 O(1) 이다.

## 검사 (```& 연산```)
#### S에 x 가 있는지 검사
- ``` S & (1<<x)``` 의 결과가 0이면 없음, 0이 아니면(정확히는 ```1<<x```의 결과) 있음
- 값이 중요한것이 아니라 0인지 0이 아닌지만 판단하면 된다. <br>

```S = {1, 3, 4, 5, 9} = 570```
#### 0이 포함되어 있는지 검사
- ```570```의 0번째 비트가 ```0```인지 ```1```인지 검사하면 된다.
- ```570 & 2⁰ = (570 << 0) = 0``` <br>

#### 1이 포함되어 있는지 검사
- ```570```의 1번째 비트가 ```0```인지 ```1```인지 검사하면 된다.
- ```570 & 2¹ = (570 << 1) = 2``` <br>

#### 2가 포함되어 있는지 검사
- ```570```의 1번째 비트가 ```0```인지 ```1```인지 검사하면 된다.
- ```570 & 2² = (570 << 2) = 0``` <br>
  <img width="378" alt="스크린샷 2023-03-20 오후 4 59 25" src="https://user-images.githubusercontent.com/96982575/226279717-8ec88504-9b9c-4b63-a5f9-b931e6813556.png">


#### 3이 포함되어 있는지 검사
- ```570```의 3번째 비트가 ```0```인지 ```1```인지 검사하면 된다.
- ```570 & 2³ = (570 << 3) = 8``` <br>
  <img width="380" alt="스크린샷 2023-03-20 오후 5 04 53" src="https://user-images.githubusercontent.com/96982575/226280725-dc432da4-1105-42ba-a687-4beb1d12fd4f.png">


## 추가 (```OR 연산```)
#### S에 X를 추가 -> S의 X번째 비트를 1로 변경한다 = ```S | (1<<X)```<br>

```S = {1, 3, 4, 5, 9} = 570```
#### S에 1 추가하기
- ```570 | 2¹ = 570``` = ```570 | (1<<1)``` = ```570 (1000111010₂)``` <br>
<img width="377" alt="스크린샷 2023-03-20 오후 5 48 44" src="https://user-images.githubusercontent.com/96982575/226514926-adbbbecd-9d59-40b1-9f19-fe53646734ed.png">


#### S에 2 추가하기
- ```570 | 2² = 570``` = ```570 | (1<<2)``` = ```574 (1000111110₂)``` <br>
<img width="380" alt="스크린샷 2023-03-20 오후 5 48 56" src="https://user-images.githubusercontent.com/96982575/226514977-6f257ab4-77d2-477e-9269-1b47e168af49.png">


#### S에 3 추가하기
- ```574 | 2³ = 574``` = ```570 | (1<<3)``` = ```570 (1000111110₂)``` <br>
<img width="375" alt="스크린샷 2023-03-20 오후 5 49 07" src="https://user-images.githubusercontent.com/96982575/226515009-63de1c1e-c033-4d9e-afdc-18c0acbf581a.png">


#### S에 4 추가하기
- ```570 | 2⁴ = 574``` = ```570 | (1<<4)``` = ```570 (1000111110₂)``` <br>
<img width="385" alt="스크린샷 2023-03-20 오후 5 49 22" src="https://user-images.githubusercontent.com/96982575/226515018-53baa748-714a-4193-a737-da829244fac9.png">


#### 이미 있는 수가 추가되어도 OR 연산에 의해 같은 변함없이 1이다

## 제거
```S = {1, 3, 4, 5, 9} = 570```

#### S에서 1 제거하기
``` 570 & ~2¹``` = ```570 &= ~(1<<1)``` = ```568 (1000111000₂)``` <br>
<img width="384" alt="스크린샷 2023-03-20 오후 5 43 57" src="https://user-images.githubusercontent.com/96982575/226288993-78f8ce35-18d0-49d2-919d-68e3150d1cc9.png">


#### S에서 2 제거하기
``` 570 & ~2²``` = ```570 &= ~(1<<2)``` = ```570 (1000111010₂)``` <br>
<img width="368" alt="스크린샷 2023-03-20 오후 5 44 13" src="https://user-images.githubusercontent.com/96982575/226289024-1b98769f-7b6b-457e-a6a8-8e08ae8e1b12.png">


#### S에서 3 제거하기
``` 570 & ~2³``` = ```570 &= ~(1<<3)```  ```562 (1000110010₂)``` <br>
<img width="384" alt="스크린샷 2023-03-20 오후 5 44 29" src="https://user-images.githubusercontent.com/96982575/226289049-24ad5054-f7d1-49d4-a207-ffd29dea0657.png">


#### S에서 4 제거하기
``` 570 & ~2⁴``` = ```570 &= ~(1<<4)``` = ```546 (1000101010₂)``` <br>
<img width="373" alt="스크린샷 2023-03-20 오후 5 44 49" src="https://user-images.githubusercontent.com/96982575/226289071-fc8edee7-38d1-4ecd-8d02-8a5be03a1b7c.png">


## 전체집합
N개의 수를 집합에 저장: 0 ~ (N-1)
- ```(1 << N) -1```

## 공집합
- 0

## 정리
현재 집합이 S일때
### i를 추가
```S | (1 << i)```

### i를 검사
```S & (1 << i)```

### i를 제거
```S & ~(1 << i)```

### i를 토글
```S ^ (1 << i)```

## 주의
비트 연산을 사용할 때는 연산자 우선 순위를 생각해야 한다. <br>
 ```+```, ```-``` 보다 ```*```, ```/``` 가 우선 순위이다. <br>
그렇다면  ```1 << N-1``` 은 ```(1 << N) - 1``` 일까? ```1 << (N-1)``` 일까?
- 정답은 ```1 << (N-1)``` 이다
- 각각의 언어마다 연산자 우선순위를 외우는것도 방법이지만 언젠간 까먹을 것이다.
- 괄호```()```를 이용하여 계산하는것이 가장 정확하고 좋은 방법이다.
