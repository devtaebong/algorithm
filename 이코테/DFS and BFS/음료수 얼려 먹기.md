# 문제
- N x M 크기의 얼음틀이 있다.
- 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다.
- 구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결된 것으로 간주한다.
- 얼음 틀의 모잉이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성한다.

# 입력조건
- 첫 번째 줄에 얼음 틀의 세로 길이 N과 가로 길이 M이 주어진다. (1 <= N, M <= 1,000)
- 두 번째 줄부터 N + 1 번째 줄까지 얼음 틀의 형태가 주어진다.
- 이때 구멍이 뚫려있는 부분은 0, 그렇지 않은 부분은 1이다.

# 출력조건
- 한 번에 만들 수 있는 아이스크림의 개수를 출력한다.

# 입력 예시
```
4 5
00110
00011
11111
00000
```

```
15 14
00000111100000
11111101111110
11011101101110
11011101101110
11011101100000
11011111111111
11011111111100
11000000011111
01111111111111
01111111111000
00011111111000
00000001111000
11111111110011
11100011111111
11100011111111
```

# 출력 예시
```
3
```

```
8
```

# 풀이 코드
``` python
n, m = map(int, input().split(" "))
matrix = [list(map(int, input())) for _ in range(n)]

"""
graph = []
for i in range(n):
    graph.append(list(map(int, input()))
"""


def dfs(rows, cols):
    if rows <= -1 or rows >= n or cols <= 1 or cols >= m:
        return False

    if matrix[rows][cols] == 0:
        matrix[rows][cols] = 1
        dfs(rows - 1, cols)  # 상
        dfs(rows + 1, cols)  # 하
        dfs(rows, cols - 1)  # 좌
        dfs(rows, cols + 1)  # 우
        return True

    return False


answer = 0
for i in range(n):
    for j in range(m):
        if dfs(i, j) == True:
            answer += 1

print(answer)
```

# 풀이과정
1. 입력값을 받아온다. 첫번째 줄에서 얼음 틀의 세로 길이 N과 가로 길이 M을 받아오고, 그 다음 N개의 줄에서 각각 M개의 숫자를 입력받아 2차원 리스트 matrix에 저장해준다.

2. dfs 함수를 정의한다. dfs함수는 특정위치(rows, cols)에서 연결된 0의 개수를 반환하는 함수이다. matirx[rows][cols]가 0인경우 해당 위치를 1로 변경하고 상하좌우 방향으로 dfs함수를 재귀적으로 호출한다. 이렇게 하면 해당 위치에서 연결된 0들을 모두 1로 바꿀수 있다. 마지막으로 연결된 0이 없는 경우 False를 반환한다.

3. answer 변수를 0으로 초기화한 후, matrix의 모든 위치에 대해 dfs 함수를 호출하여 연결된 0의 개수를 구하고, 이를 answer에 더하고 출력하여 답을 구하였다.

4. 최종적으로 구한 answer 값을 출력한다.

# 시간복잡도와 공간복잡도
이 코드의 시간복잡도는 각 위치에서 DFS를 호출하는 것으로, 이중 반복문으로 모든 위치를 순회하므로 O(NM)이 된다.

공간복잡도는 입력으로 받은 얼음 틀을 저장하는 2차원 리스트 matrix가 필요하므로 O(NM)이 된다.

따라서 이 코드의 시간복잡도는 입력크기에 비례하고, 공간복잡도도 입력크기에 비례한다. 입력크기가 커질수록 실행 시간과 메모리 사용량이 증가하게 된다. 하지만 이 문제에서는 입력 크기가 최대 1000x1000이므로, 이 코드는 충분히 효율적인 알고리즘이라고 할 수 있을 것이다.
