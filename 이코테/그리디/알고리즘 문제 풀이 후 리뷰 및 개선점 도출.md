# 큰 수의 법칙 (3-2)
## 문제
다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 법칙의 특징이다.

예를들어 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자. 이경우 특정한 인덱스의 수가 연속해서 세번 까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는
6+6+6+5+6+6+6+5 인 46이 된다.

단 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로다른것으로 간주한다.

배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질때 큰수의 법칙에 따른 결과를 출력하시오

## 입력조건
- 첫째 줄에 N(2<= N <= 1000), M(1<= M <= 10000), K(1<= K <= 10000)의 자연수가 주어지며 각 자연수는 공백으로 구분한다.
- 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다.
- 입력으로 주어지는 K는 항상 M보다 작거나 같다.

## 내 풀이
``` python
import sys
sys.stdin=open("input.txt", "rt")

n,m,k = map(int, input().split(" "))
data = list(map(int, input().split(" ")))

# 배열의 수를 M번 더하여 가장 큰 수를 만든다
# 특정 인덱스 번호가 K번을 초과해서 반복될 수 없다.
# 2 4 5 4 6 의 배열에 6+6+6+5+6+6+6+5
data.sort(reverse=True)

sum = 0
cnt = 0
for i in range(m):
    if cnt < 3:
        sum += data[0]
        cnt += 1
        continue

    if cnt == 3:
        sum += data[1]
        cnt = 0
        continue
print(sum)
```
<br>
data = [2, 4, 5, 4, 6], K=8, M=3 이 주어진다고 가정했을때 정답은 6+6+6+5+6+6+6+5 가 되어야 한다.

위 배열에서 가장 큰 수와 두번째가 무엇인지 알아내야 하므로 배열을 내림차순 정렬해주었다.
가장큰 수인 data[0]과 두번째로 큰수인 data[1]을 변수에 따로 선언해주어도 좋을 것 같다.

sum 이라는 변수에 누적합을 저장하고 cnt 변수에 같은 수가 몇번 반복되었는지 저장해주었다.
여기서 같은 수는 가장 큰 수가 되어야 한다. 같은 수가 K번(여기서는 3번) 반복되면 누적합에 두번째로 큰 수를 더해주고 cnt를 다시 0으로 초기화 해주어 정답을 구했다.

### 개선점
처음에 if문 안에 continue를 넣어주어야 한다는것을 생각하지 못했다. 그래서 cnt가 3일때, 가장 큰수와 두번째로 큰 수가 모두 더해졌었다.
조건에 따라 수를 더하거나 빼는등의 작업을 할때 continue와 break를 잘 생각할 필요가 있을 것이다.

## 정답 풀이
```python
first = data[0] # 가장 큰 수
second = data[1] # 두 번째로 큰 수

# 가장 큰 수가 더해지는 횟수
count = m//(k+1) * k
count += m % (k+1)

# 결과
result = 0
result += count * first # 가장 큰 수 더하기
result += (m-count) * second # 두 번째로 큰 수 더하기
print(result)
```

data = [2, 4, 5, 4, 6], M=8, K=3 일때 (6+6+6+5) + (6+6+6+5) 라는 규칙을 찾을 수 있다.
만약 M=12 라면 (6+6+6+5)+(6+6+6+5)+(6+6+6+5)가 될 것이다. 따라서 가장 큰 수인 6이 더해지는 횟수는 12//4*3 = 9가 되고 두번째 수인 5가 더해지는 횟수는 12-9 = 3이 된다.

하지만 M이 (k+1)로 나누어 떨어지지 않는 경우도 고려해야 한다.
만약 M=11 이라면 (6+6+6+5)+(6+6+6+5)+(6+6+6)이 될 것이다. <br>
이런 경우 m//(k+1)*k + m % (k+1)이 가장 큰수가 더해지는 횟수가 된다.

즉, ```m//(k+1)*k + m%(k+1)``` 이 가장 큰 수인 first가 더해지는 횟수이다.
